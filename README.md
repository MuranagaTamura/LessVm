# TestVm3
VMを実装したい



# 仕様

## オペコード

VMのバイトコードは可変長であり，最大でも48bit（6byte）．

引数は最大2個．

| OPCODE（u8） | ARG0      | ARG1      | 内容                                          |
| ------------ | --------- | --------- | --------------------------------------------- |
| LOAD_B       | R (u8)    | Mem (u16) | メモリからレジスタに格納 (u8)                 |
| LOAD_W       | R (u8)    | Mem (u16) | メモリからレジスタに格納 (u16)                |
| LOAD_D       | R (u8)    | Mem (u16) | メモリからレジスタに格納 (u32)                |
| STORE_B      | R (u8)    | Mem (u16) | レジスタからメモリに格納 (u8)                 |
| STORE_W      | R (u8)    | Mem (u16) | レジスタからメモリに格納 (u16)                |
| STORE_D      | R (u8)    | Mem (u16) | レジスタからメモリに格納 (u32)                |
| MOVE_I_B     | R (u8)    | Imm (u8)  | 即値からレジスタに格納 (u8)                   |
| MOVE_I_W     | R (u8)    | Imm (u16) | 即値からレジスタに格納 (u16)                  |
| MOVE_I_D     | R (u8)    | Imm (u32) | 即値からレジスタに格納 (u32)                  |
| MOVE_B       | R (u8)    | R (u8)    | レジスタからレジスタに格納 (u8)               |
| MOVE_W       | R (u8)    | R (u8)    | レジスタからレジスタに格納 (u16)              |
| MOVE_D       | R (u8)    | R (u8)    | レジスタからレジスタに格納 (u32)              |
| ADD_B        | R (u8)    | R (u8)    | レジスタ同士の加算結果を格納 (u8)             |
| ADD_W        | R (u8)    | R (u8)    | レジスタ同士の加算結果を格納 (u16)            |
| ADD_D        | R (u8)    | R (u8)    | レジスタ同士の加算結果を格納 (u32)            |
| SUB_B        | R (u8)    | R (u8)    | レジスタ同士の減算結果を格納 (u8)             |
| SUB_W        | R (u8)    | R (u8)    | レジスタ同士の減算結果を格納 (u16)            |
| SUB_D        | R (u8)    | R (u8)    | レジスタ同士の減算結果を格納 (u32)            |
| MUL_B        | R (u8)    | R (u8)    | レジスタ同士の乗算結果を格納 (u8)             |
| MUL_W        | R (u8)    | R (u8)    | レジスタ同士の乗算結果を格納 (u16)            |
| MUL_D        | R (u8)    | R (u8)    | レジスタ同士の乗算結果を格納 (u32)            |
| DIV_B        | R (u8)    | R (u8)    | レジスタ同士の除算結果を格納 (u8)             |
| DIV_W        | R (u8)    | R (u8)    | レジスタ同士の除算結果を格納 (u16)            |
| DIV_D        | R (u8)    | R (u8)    | レジスタ同士の除算結果を格納 (u32)            |
| REM_B        | R (u8)    | R (u8)    | レジスタ同士の余算結果を格納 (u8)             |
| REM_W        | R (u8)    | R (u8)    | レジスタ同士の余算結果を格納 (u16)            |
| REM_D        | R (u8)    | R (u8)    | レジスタ同士の余算結果を格納 (u32)            |
| SLL_B        | R (u8)    | Imm (u8)  | レジスタ値を定数で左シフト結果を格納 (u8)     |
| SLL_W        | R (u8)    | Imm (u8)  | レジスタ値を定数で左シフト結果を格納 (u16)    |
| SLL_D        | R (u8)    | Imm (u16) | レジスタ値を定数で左シフト結果を格納 (u32)    |
| SRL_B        | R (u8)    | Imm (u8)  | レジスタ値を定数で右シフト結果を格納 (u8)     |
| SRL_W        | R (u8)    | Imm (u8)  | レジスタ値を定数で右シフト結果を格納 (u16)    |
| SRL_D        | R (u8)    | Imm (u16) | レジスタ値を定数で右シフト結果を格納 (u32)    |
| AND_B        | R (u8)    | R (u8)    | レジスタ同士の論理積結果を格納 (u8)           |
| AND_W        | R (u8)    | R (u8)    | レジスタ同士の論理積結果を格納 (u16)          |
| AND_D        | R (u8)    | R (u8)    | レジスタ同士の論理積結果を格納 (u32)          |
| OR_B         | R (u8)    | R (u8)    | レジスタ同士の論理和結果を格納 (u8)           |
| OR_W         | R (u8)    | R (u8)    | レジスタ同士の論理和結果を格納 (u16)          |
| OR_D         | R (u8)    | R (u8)    | レジスタ同士の論理和結果を格納 (u32)          |
| XOR_B        | R (u8)    | R (u8)    | レジスタ同士の排他的論理和結果を格納 (u8)     |
| XOR_W        | R (u8)    | R (u8)    | レジスタ同士の排他的論理和結果を格納 (u16)    |
| XOR_D        | R (u8)    | R (u8)    | レジスタ同士の排他的論理和結果を格納 (u32)    |
| CMP_B        | R (u8)    | R (u8)    | レジスタ同士を比較結果をフラグに設定 (u8)     |
| CMP_W        | R (u8)    | R (u8)    | レジスタ同士を比較結果をフラグに設定 (u16)    |
| CMP_D        | R (u8)    | R (u8)    | レジスタ同士を比較結果をフラグに設定 (u32)    |
| JMP          | Imm (u16) |           | 即値にジャンプ                                |
| JEQ          | Imm (u16) |           | Zeroフラグがtrueならジャンプ                  |
| JNE          | Imm (u16) |           | Zeroフラグがfalseならジャンプ                 |
| JLT          | Imm (u16) |           | SignフラグがtrueかつZeroフラグがfalseジャンプ |
| SYSCALL      | Imm (u16) |           | エンジン側で実装されている関数を実行          |



## 記憶領域

### レジスタ

* レジスタは**64個**存在
* 32bit (4byte)レジスタを取得する場合，4nの整数 (0含む)で指定
* 16bit (2byte)レジスタを取得場合，4n+1の整数で指定
* 16bit (2byte)レジスタの上位8bit (1byte)を取得する場合，4n+2の整数で指定
* 16bit (2byte)レジスタの下位8bit (1byte)を取得する場合，4n+3の整数で指定
* レジスタ番号の0~3はスタックポインタを表すレジスタ
* レジスタ番号の4~7はベースポインタを表すレジスタ



### メモリ

* メモリはbyte配列の**サイズ4096**で表現
* メモリアクセスにおいてTryGet～で取得を行い，TrySet～で設定を行う
  * ～にはそれぞれUi32, Ui16, Ui8が用意されている



## システムコール

ここでいうシステムコールとは，エンジン側に実装されている関数を呼び出し実行するという意味です．

エンジン側では以下の関数に基づいて実行される．

* 関数は以下のように定義されるものを実行する

  ```csharp
  System.Collections.Generic.IEnumerator<int> Method(VmStatus status);
  ```

* 実行時には引数や返り値がどこに保存されているかはエンジン使用者が定義する

* VmStatusはエンジン側のメモリ空間とは別の空間に確保されているため，内容を変更してもFINISHを返さない限りエンジンの状態には影響を及ぼさない

* 関数は上記で示してあるように，intで返るようになっておりそれぞれVmStatusの定数に以下の内容が定義されており，これをもとにエンジン側の処理が決定される

  | 定数         | 内容                                 |
  | ------------ | ------------------------------------ |
  | FINISH = 0   | システムコールが正常に終了した       |
  | CONTINUE = 1 | システムコールが途中で停止させた状態 |
  | HALT = 2     | システムコールが異常に終了した       |



# スクリプト

スクリプトをバイトコードに変換する際に必要なファイルとして，「ScriptHelper」にあるすべてのソースをコピーしてください．



## バイトコード生成例

スクリプトを構文解析し，コードを生成したいとする．その際，以下のコードを生成したいと考えた．

```
ADD R0(u32) R1(u32)
```

これをするためには以下のコードを記述すると表現できる．

```csharp
// using System.Collections.Generic;
List<byte> code = new List<byte>();
code.GenAdd(0, 4);
```

また，レジスタ指定を簡略化したい場合は，以下のヘルパーを使う．

```csharp
// R0(u32)
GenerateCode.GenRegId(0, RegType.u32);
// R1(u32)
GenerateCode.GenRegId(1, RegType.u32);
```



## 注意事項（ScriptHelper）

* 基本的にレジスタのアクセスIDに応じて命令の型（e.g. LoadのI8ならLoadB）に変換してくれる
* レジスタを複数指定される命令（e.g. AddB, SubD）は第一引数に相当するレジスタの値に対応し，第二引数もほぼ自動的に変換される
* レジスタIDの変換規則としては，u32とu16においてはそのまま変換されるが，u8について変換される場合はLで変換される



以下，メモ書き

---

# システムコール（MEMO）

* システムコールをコンパイラに知らせれるように属性を使用する
* 属性（スクリプト使用名，返り値タイプ，引数タイプ）
* エンジン側では型の保証はしてくれない
  * あくまでも，関数を実行するだけ
  * 関数の引数もVmの状態を渡すだけで，引数内容取得とかは別途実装する
  * 関数はIEnumrator\<int\>で実装する
    * MoveNextでFinishまでエンジンの処理を止めるため
    * Finishはintで~~-1~~0が返ってくるなどにする
  * 引数がどこに保存されているかはスクリプトのコンパイラに依存
* VmStatusの便利関数などは拡張メソッドで実装するなど，スクリプト側の実装に委譲させる